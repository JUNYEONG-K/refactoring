# 리팩토링 개론

## 리팩토링은 무엇인가
* 겉으로 드러나는 기능은 그대로 둔 채, 알아보기 쉽고 수정하기 간편하게 소프트웨어 내부를 수정하는 작업
* 리팩토링 기법을 연달아 적용해서 겉으로 드러나는 기능은 그대로 둔 채 소프트웨어 구조를 변경한다.

리팩토링은 단순히 코드를 정리하는 작업이 아니다. 코드 효율성을 높이고 구조를 체계화할 수 있다.

다만 이를 위해선 내가 어떤 리팩토링 기법을 적용하는 것이 적절할지, 어떤 리팩토링 기법을 활용하고 있는지 알고 있는 것이 좋다.

내가 생각하기에 리팩토링의 큰 효과는, ```수정하기 쉽게 만들고, 수정할 영역을 최소화하는 것이다.```

** 리팩토링 != 성능 최적화

### 켄트 백의 모자 두개 비유법
```기능 추가 모자```와 ```리팩토링 모자```

기능을 추가할 땐 코드를 수정하지 말고 기능만 추가해야 한다. 진행 상태를 파악하려면 테스트를 추가하고 그 테스트들이 제대로 되는지 알아내면 된다.

리팩토링을 할 때에는 코드를 추가하지 말고 코드 구조 개선만 해야 한다. 앞서 실수한 게 없다면 테스트는 전혀 추가하지 말고 오로지 코드 구조만 수정해야 한다.

** 만약 인터페이스가 수정되어 그에 맞게 코드를 고치는 것이 불가피할 땐 테스트만 변경해야 한다.

우리는 요 2가지 모자를 자주 번갈아 쓰면서 작업을 해야 한다.

## 리팩토링은 왜 해야 하나

* 소프트웨어 설계 개선

코드 구조는 한 번 엉망이 되면 갈수록 뒤죽박죽된다. 매우 인정한다. 설계라는 모든 것이 사실 그렇다. 디비 설계, 백엔드 인프라 설계 등...

코드 설계를 개선하는 주요 비법 중 하나는 `중복을 제거하는 것이다.`
이는 나중에 코드를 수정할 때 빛을 바란다. 수정할 영역이 줄어들고, 코드가 이미 짧기 때문에 정확한 코드 이해에 용이하고, 이로 인해 어느 부분을 수정해야할지 파악하기 쉽다.

* 소프트웨어에 대한 쉬운 이해

우리는 주로 협업을 한다. 코드를 작성하면, 개똥같이 작성해도 컴퓨터는 알아먹는다. 프로그램도 잘 돌아갈 것이고. 하지만 우리 팀원들이 알아먹을 수 있을까?

아니 팀원까지 갈 필요도 없다. 가까운 미래의 내가 알아먹을 수 있을까?

프로그래밍에서 가장 중요한 것은 `의도한 바를 정확히 전달 하는 것이다.` 이러한 이유로 우리는 구조 뿐 아니라 네이밍에 대해서 많은 고민들을 하곤 한다.

* 버그를 찾기 쉬워진다.

광활한 코드를 보면 버그를 찾기 쉽다는 사람도 있다. 머리가 좋은 사람일 것이다. 하지만 난 그렇지 않다.

켄트 백은 이런 식으로 자기암시를 되뇌였다고 한다.
"난 뛰어난 프로그래머는 아니고, 단지 습관을 잘 들인 착실한 프로그래머다."

나 또한 그렇다. 그리고 대부분 그렇다.

* 프로그래밍 속도가 빨라진다.

깔끔한 설계를 바탕으로 한 개발은 쉽고 생산성이 높아진다.
복잡하고 이상한 설계를 바탕으로 한 개발은, 이해부터가 쉽지 않다.

## 리팩토링은 어떨 때 필요한가

리팩토링을 위해 따로 시간을 주기적으로 내는 것이 좋을까?

아니다. 리팩토링이 필요하다고 느껴지는 시점에 하면 된다.

어떤 새로운 기능을 추가하거나 다른 작업을 해야겠는데, 리팩토링을 실시하면 그 작업이 쉬워질 것이라는 생각이 들 때 하면 된다.

실제 내가 이 책을 읽게 된 이유가 이것이다.
마침 내가 리팩토링이 필요하다고 느꼈고, 리팩토링을 진행하던 시점이었다.
리팩토링을 하는 김에 좋은 코드를 작성하고 싶어서 이 책을 읽게 되었다.

굳이 리팩토링이 필요한 시기를 정의하자면 아래와 같다.

* 같은 작업의 삼진 아웃 때 (3번째 반복작업)
* 기능을 추가할 때
* 버그를 수정할 때
* 코드를 검수할 때

### 리팩토링의 효용성 - 켄트 벡

프로그램이 지닌 가치는 두 종류이다. `현재의 기능`, `미래의 기능`

개발자는 주로 `현재의 기능`에 집중하지만, `현재의 기능`은 일부에 불과하다는 사실을 깨우쳐야 한다. 

`미래의 기능`을 효과적으로 달성하기 위해선, 리팩토링이 필요한 것이다.

아래와 같은 4가지 상황은 코드를 수정하기 힘들게 만든다.

* 코드를 알아보기 힘들 때
* 중복된 로직이 들어 있을 때
* 추가 기능을 넣어야 해서 실행 중인 코드를 변경해야 할 때
* 조건문 구조가 복잡할 때

그러므로 프로그램은 코드를 알아보기 쉽고, 모든 로직이 한 곳에 있으며, 기존 기능을 건드릴 필요 없이 조건문 구조가 최대한 간결하게끔 작성해야 한다.

## 리팩토링 관련 문제들

### 데이터베이스

대부분의 애플리케이션은 데이터베이스 스키마와 강력히 결합되어 있다.
그래서 둘 중에 하나의 수정이 다른 한 쪽에 영향을 강하게 미치거나, 혹은 수정이 불가할 경우가 있다.

이런 경우를 피하기 위해선 애플리케이션과 데이터베이스 사이에 중간 계층을 하나 두는 것이 좋다. DAO 같은 것들

### 인터페이스 변경

리팩토링을 통해 인터페이스를 수정하는 경우에는, 기존 인터페이스와 신규 인터페이스를 모두 유지시켜야하는 경우가 발생할 수 있다.

## 리팩토링과 설계

대부분 이런 순서를 겪는 것 같다.

> 무지성 코드 작성 -> 설계의 중요성 깨달음. 유연한 대처, 수정에 용이한 코드 -> 설계에 매진

그렇지 않다면 뭐 ㅎ 어쩔 수 없다. 적어도 나는 그런 과정을 거쳤다. 함수를 얼마나 쪼개야하는지, 모듈 구조나 컴포넌트 구조 등은 어떻게 세워두면 좋을지 등등...
코드를 짜기 전부터 설계에 목을 맸다.

하지만 리팩토링이 있는 지금은 다르다. 설계에 목을 매지 않아도 된다. 단순하게 코드를 작성하고, 리팩토링을 통해 개선하고, 다시 단순하게 작성하고, 리팩토링을 통해 개선하고...

그럼 리팩토링은 언제 하냐고? 위에서 언급한 시점에 하면 된다. 필요한 시점에. 그렇게 되면 설계에 목을 매느라 시간을 낭비하지 않을 수 있고, 투머치하게 유연한 설계를 하지 않을 수도 있다.
시기적절하게 필요한 때에 작업하면 된다.

리팩토링은 설계에 대한 부담을 줄여준다. 물론 최소한의 설계는 해야겠지만.

이를 통해 얻게 되는 장점은 오히려 설계가 단순해진다는 것이다. 유연한 솔루션에 목매지 않고 적당한 솔루션으로 시작해 생산성을 높인다. 이후 점진적으로 리팩토링을 통해 유연한 설계를 가져갈 수 있다.

게다가 전체 시스템이 유연할 필요는 없다. 유연할 필요가 있는 부분은 꽤나 제한적이고, 그 부분을 예측하는 것도 어렵다.

잘 돌아갈 정도의 단순하고 적당한 솔루션을 구축하자. 이후 필요할 때 리팩토링하면 되니까.

## 리팩토링과 성능
리팩토링을 하는 동안에는 단기적으로 소프트웨어가 느려진다. 하지만 프로그램을 잘 쪼개놓으면 다음과 같은 장점을 지닌다.

* 코드가 잘 쪼개져 있어 기능 추가가 신속히 이루어진다. 이로 인해 성능 튜닝에 할애할 시간이 생긴다.
* 성능 분석 시, 더 정밀한 성능 분석이 가능하다.
