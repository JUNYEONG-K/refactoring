# 코드의 구린내

리팩토링은 어떻게 하느냐도 중요하지만 언제 해야하는 지를 아는 것도 중요하다. 그리고 그걸 아는 것은 생각보다 어렵다.

## 중복 코드 Duplicated Code

구린내가 나는 코드의 탑티어. 이건 그냥 기본이다.

* 두 개 이상 메서드에 동일한 로직의 코드가 들어 있는 경우
  * 바로 그냥 `메서드 추출(Extract Method)` 갈겨야한다. -> `중복을 없앰.`
  * 이후 `메서드 상향(Pull Up)`
* 동일하진 않고 비슷하다면?
  * 일단 `메서드 추출(Extract Method)` 조지고, 같은 부분과 다른 부분을 분리해야 한다.
  * 경우에 따라 `템플릿 메서드 형성(Form Template Method)` 기법이 필요할 수도
* 알고리즘만 다르고 동일한 기능을 한다면?
  * 당연히 더 간단한 알고리즘을 택해서 `알고리즘 전환(Substitute Algorithm)` 해야지.
* 중복 코드가 메서드의 가운데에 있다면?
  * `주변 메서드 추출(Extract Surrounding Method)`


* 서로 상관 없는 두 클래스 안에 중복 코드가 있을 경우
  * 한 클래스 안의 중복 코드를 `클래스 추출(Extract Class)` 하거나 `모듈 추출(Extract Module)` 하여 제 3의 클래스나 모듈로 떼어낸 후 그것을 다른 클래스에서 호출하는 방법이 있다.
  * 혹은 중복 코드를 빼서 메서드로 만든 후 그 메서드를 두 클래스 중 하나에 넣고 다른 클래스에서 그 메서드를 호출한다.
  * 혹은 코드를 빼내어 만든 메서드를 제 3의 클래스에 넣고 그걸 두 클래스에서 호출하는 방법이 있다.

이처럼 여러 방법이 있지만, `중요한 것은 하나의 독립된 메서드로 분리하는 것이다.`

## 장황한 메서드 Long Method

최적의 상태로 장수하는 객체 프로그램을 보면, 공통적으로 메서드 길이가 짧다.

** 작은 메서드의 효과 -> 인다이렉션으로 설명, 공유, 선택 등의 효과를 누림.

다만 메서드를 작게 작게 만들어놓으면 기능 파악에 어려움을 겪을 수도 있다.
이전에는 함수 호출에 대한 오버헤드를 걱정해서 기피했지만, 이는 현재는 현저히 줄어든 상태이다. 

하지만 문제는 이해하려는 사람의 머릿 속에 오버헤드가 생긴다는 것이다.

이런 문제점을 극복하기 위해선 `메서드의 기능을 한 눈에 알 수 있는 명확한 메서드명을 사용해야 한다.` 굳이 모든 메서드 하나하나의 내부 구현을 뜯어보지 않아도 되도록 말이다.

이를 위해서는 메서드를 훨씬 더 과감하게 쪼개야 한다. 켄트와 파울러는 주석을 달아야 할 것 같은 부분에 주석을 넣는 대신 메서드를 작성한다고 한다. 그리고 메서드명으로 해당 함수의 동작이나 목적을 나타낸다.

`메서드에 매개변수와 임시변수가 많으면 메서드를 추출하기 까다롭다.`

* 웬만한 경우에는 임시변수를 `메서드 호출(Replace Temp with Query)`로 대체하여 제거하거나, `메서드 체인으로 전환(Replace Temp with Chain)`하여 임시변수를 제거하자.
* 길게 열거된 매개변수는, `매개변수 세트를 객체로 전환(Introduce Parameter Object)`하거나 `객체를 통째로 전달(Preserve Whole Object)`하여 간결하게 하자.

위와 같은 리팩토링 과정을 거쳤음에도 여전히 임시변수와 매개변수가 너무 많다면, `메서드를 메서드 객체로 전환(Replace Method with Method Object)`하자.

`조건문과 루프도 역시 메서드로 빼면 좋다.`

* 조건문 추출 -> `조건문 쪼개기(Decompose Conditional)`
* 루프 추출 -> 루프를 `컬렉션 클로저 메서드로 전환(Replace Loop with Collection Closure Method)` 후 그 클로저 메서드를 호출하고 클로저 자체를 `메서드 추출(Extract Method)` 할 수 있다.

## 방대한 클래스 Large Class

방대한 클래스는 코드 중복을 일으키기 쉽다. 

>보통 엄청난 수의 인스턴스 변수를 포함하고 있을 것이기 때문이다.

`클래스 추출(Extract Class)`을 통해서 수많은 인스턴스 변수를 하나로 묶을 수 있다. 서로 연관된 변수를 골라서 클래스로 빼내면 된다.
`depositAmount`와 `depositCurrency`는 한 클래스로 묶이는게 좋을 것 같다.

한 클래스 안의 일부 변수 접두어나 접미어가 같다면 하나의 클래스로 추출해봄직하다.

하위 클래스로 추출하는 것이 적합할 것 같을 땐 `하위 클래스 추출(Extract Subclass)`, 추출할 클래스가 대리자로 부적절할 것 같으면 `모듈 추출(Extract Module)`을 고민해볼 수도 있다.

> 코드 분량이 너무 방대한 클래스도 코드 중복을 일으키기 쉽다.

이에 대한 제일 간단한 해결책은 해당 클래스 자체에서 중복 코드를 없애는 것이다. 또한 해당 경우에도 위에서 언급한 추출법들을 활용할 수 있다.

혹은 클라이언트가 그 클래스를 어떻게 사용하게 할지 결정하고, 그러한 각 사용 방법마다 `인터페이스 추출(Extract Interface)` 을 실시하기도 한다. (편법?이라고 책에서는 소개한다. 왜지?)

## 과다한 매개변수 Long Parameter List

요건 요즘 내가 고민하고 있는 부분이다. 매개변수는 어느 정도 선에서 관리하는 것이 좋을까...

매개변수 세트는 간결한 것이 좋다. 

* `매개변수 세트를 메서드로 전환(Replace Parameter with Method)`: 이미 알고 있는 객체에 요청하여 한 매개변수에 들어 있는 데이터를 가져올 수 있을 때
* `객체를 통째로 전달(Preserve Whole Object)`: 객체에 있는 데이터 세트를 가져온 후, 데이터 세트를 그 객체 자체로 전환
* `매개변수 세트를 객체로 전환(Introduce Parameter Object)`: 여러 데이터 항목에 논리적 객체가 없을 때

위 방법들을 적용할 때에는 예외가 하나 있다. 그것은 바로 `호출되는 객체가 호출 객체에 의존하면 안될 때다.` 이럴 때는 데이터를 개별적으로 빼서 매개변수로 전달해야 한다.


## 수정의 산발 Divergent Change

개발자는 소프트웨어를 수정하기 쉽게 구성해야 한다. 말 그대로 '소프트'웨어이기 때문이다.
> 수정할 때 개발자는 시스템의 분명한 위치로 곧장 가서 수정할 수 있어야 한다.

만약 그럴 수 없다면 밀접하게 관련된 두 가지 문제 중 하나를 의심해보자.

* 수정의 산발은 한 클래스가 다양한 원인 때문에 다양한 방식으로 자주 수정될 때 발생
  * ex. 어떤 클래스에 대해, 새 데이터베이스를 생성할 때마다 3개의 메서드를 수정해야하고, 새 금융 상품을 추가할 때마다 4개의 메서드를 수정해야 한다.
  * 이럴 땐 해당 클래스를 여러 개의 변형 객체로 분리하는 것이 좋다. 그러면 각 객체는 한 종류의 수정에 의해서만 변경된다.
    * 예를 들어 상속 -> 하위 클래스에서 재정의하지 않았다면 상위 클래스의 수정만으로 각 하위 클래스에 반영됨.

하지만 요론건 주로 데이터베이스나 금융 상품을 적어도 두세 개 정도 추가하고 나서야 발견된다. 나도 그랬고 ㅋㅋ (룰렛, 퀴즈 기능... 그르릉;;)

특정 원인으로 변하는 모든 부분을 찾은 후 `클래스 추출(Extract Class)`을 통해 그 부분들을 합쳐 한 클래스로 빼내야 한다.

## 기능의 산재 Shotgun Surgery

수정의 산발과 비슷하지만 정 반대다. 수정의 산발은 한 클래스에 여러 수정이 발생하는 문제이고, 기능의 산재는 하나의 수정으로 여러 클래스가 바뀌게 되는 문제이다.
둘 중 어느 것이든 수정과 클래스가 일대일 대응이 되도록 하는 것이 베스트이다.

수정할 부분이 여기저기에 있다면 찾기도 힘들고, 분명 놓치는 곳이 있다.

이럴 때는 `메서드 이동(Move Method)`이나 `필드 이동(Move Field)`을 통해 수정할 부분들을 전부 하나의 클래스 안에 넣어야 한다. 기존의 클래스 중 어느 것에 넣기에도 부적절해 보일 때는 새 클래스를 만들어야 한다.
대개는 `클래스 내용 직접 삽입(Inline Class)`을 통해 별도 클래스에 분산되어 있던 모든 기능을 한 곳으로 가져와도 된다.

## 잘못된 소속 Feature Envy

> 객체의 핵심은 데이터와 그 데이터에 사용되는 프로세스를 한 데 묶는 기술이라는 것이다.

어떤 메서드가 자신이 속한 클래스보다 속하지 않은 클래스에 더 많이 접근한다면, 이건 뭔가 구리다.

잘못 소속된 메서드가 제일 흔히 접근하는 대상은 데이터다. 메서드가 다른 객체의 읽기 메서드를 여러번 호출하는 경우이다. (속성은 주로 private)

메서드는 더 많이 접근하는 클래스에 들어가는 것이 마땅하다. `메서드 이동(Move Method)`을 통해 더 자주 접근하는 클래스로 옮겨야 한다.
간혹 메서드의 일부분만 소속이 잘못된 경우도 있는데, 이럴 때는 그 부분을 `메서드 추출(Extract Method)`하여 알맞은 클래스로 `메서드 이동(Move Method)` 해주면 된다.

물론 매번 이렇게 간단하게 해결이 된다면 좋지만, 늘 그렇지만은 않다. 한 메서드가 여러 클래스에 들어 있는 기능을 이용할 때도 많은데, 이럴 땐 도대체 어느 클래스로 옮겨야 할까?

이 문제는, 주로 메서드가 접근하는 데이터가 어느 클래스에 제일 많이 들어있는지 파악해서 그 클래스로 옮기는 것이다. 그 전에 `메서드 추출(Extract Method)`을 통해 메서드를 여러 부분으로 쪼개놓으면 작업이 더 쉬워진다. 각 메서드들을 각 적절한 클래스로 옮겨놓으면 되기 때문이다.

## 데이터 뭉치 Data Clumps

데이터 항목은 주로 뭉쳐다니는데, 이렇게 몰려 있는 데이터 뭉치는 객체로 만드는 것이 좋다.
우선 데이터 뭉치가 필드처럼 보이는 부분을 찾아, 그 필드들을 대상으로 `클래스 추출(Extract Class)`을 통해 객체로 전환할 수 있다.
그러고 나서 메서드 시그니처를 대상으로 `매개변수 세트를 객체로 전환(Introduct Parameter Object)`하고 `객체를 통째로 전달(Preserve Whole Object)`하여 간결하게 만들어야 한다.
이렇게 하면 매개변수가 적어져 부수적으로 메서드 호출 코드가 간결해지는 효과도 누릴 수 있다. 새로생긴 객체의 속성들 중 일부만 이용하는 데이터 뭉치라 해도 효과를 볼 수 있다. 

둘 이상의 필드를 객체로 전환하면 코드가 개선된다.

## 강박적 기본 타입 사용 Primitive Obsession

기본 타입이 아닌 레코드 타입, 기본 타입 클래스, 응용 클래스 등... 여러 타입 사용가능하다. 이것이 객체의 장점

* 데이터 값을 객체로 전환(Replace Data Value with Object)
* 분류 부호를 클래스로 전환(Replace Type Code with Class): 데이터 값이 분류 부호일 때
* 분류 부호를 하위클래스로 전환(Replace Type Code with Subclasses): 조건문에 분류 부호가 사용될 때
* 분류 부호를 상태/전략 패턴으로 전환(Replace Type Code with State/Strategy): 조건문에 분류 부호가 사용될 때
* 클래스 추출(Extract Class): 뭉쳐 다녀야 할 여러 개의 필드가 있다면
* 매개변수 세트를 객체로 전환(Introduce Parameter Object): 기본 타입이 매개변수 세트에 들어 있다면
* 배열을 객체로 전환(Replace Array with Object)

## Switch Statements

객체지향 코드의 확연한 특징 중 하나는 switch 문이 비교적 적게 사용된다는 점이다. switch 문의 단점은 반드시 중복이 생긴다는 점이다. 같은 switch 문이 프로그램 곳곳에 있을 때가 많은데, 새 코드 행을 추가하려면 여기저기에 있는 같은 switch 문을 모두 찾아 수정해야 한다.

이런 문제를 해결할 수 있는 최상의 방법은 바로 `다형성, 즉 재정의를 이용하는 것이다.`

대부분의 switch 문은 고민할 필요 없이 재정의로 바꿔야 한다. 문제는 재정의를 넣을 위치인데, switch 문에는 분류 부호가 흔히 사용된다. 그럴 땐 분류 부호 값이 들어 있는 메서드나 클래스가 있어야 한다.
`메서드 추출(Extract Method)`을 통해서 switch 문을 메서드로 빼낸 후 `메서드 이동(Move Method)`을 통해서 그 메서드를 재정의할 클래스에 옮겨 넣자.
그와 동시에 `분류 부호를 하위클래스로 전환(Replace Type Code with Subclasses)` 혹은 `분류 부호를 상태/전략 패턴으로 전환(Replace Type Code with State/Strategy)` 할지 판단해야 한다.

상속 구조를 만들었다면 `조건문을 재정의로 전환(Replace Conditional with Polymorphism)` 하면 된다.

## 평행 상속 계층 Parallel Inheritance Hierarchies

이는 기능의 산재의 특수한 상황이다. 이 문제점이 있으면 한 클래스의 하위클래스를 만들 때마다, 매번 다른 클래스의 하위클래스도 만들어야 한다.

서로 다른 두 상속 계층의 클래스명 접두어가 같으면 이 문제를 의심할 수 있다.

## 직무유기 클래스 Lazy Class

하나의 클래스를 작성할 때마다 유지관리와 이해하기 위한 비용이 추가된다. 따라서 비용만큼의 기능을 수행하지 못하는 비효율적 클래스는 없애야 한다.

* 기존에는 의미가 있었으나, 리팩토링 실시로 인해 기능이 축소된 클래스
* 수정할 계획으로 작성했으나 수정을 실시하지 않아 쓸모 없어진 클래스

직무유기 클래스는 깔끔하게 제거하는 것이 좋다.
* 계층 병합 (Collapse Hierarchy)
* 클래스 내용 직접 삽입 (Inline Class) or 모듈 내용 직접 삽입 (Inline Module)

## 막연한 범용 코드 Speculative Generality

아직은 필요 없는 기능에 대해서... -> 일단은 필요한 것만 넣는 것부터 시작하자. 나중에 필요할 때 리팩토링 해도 늦지 않다.

* 별다른 기능이 없는 클래스나 모듈이 있다면: 계층 병합(Collapse Hierarchy)
* 불필요한 위임 제거: 클래스 내용 직접 삽입(Inline Class)
* 메서드에 사용되지 않는 매개변수 제거(Remove Parameter)
* 메서드명 이상하다면 변경(Rename Method)

특히 메서드나 클래스가 오직 테스트 케이스만을 위해 사요오딘다면 얘가 바로 막연한 범용 코드의 범인일 확률이 높다.

## 임시 필드 Temporary Field

어떤 객체 안에 인스턴스 변수가 특정 상황에서만 할당되는 경우가 간혹 있다. 개발자는 객체가 그 안에 들어있는 모든 변수를 이용하리라 생각하기 마련이므로 이런 코드는 파악부터가 힘들다.

이런 떠돌이 변수들이 서식할 집을 마련해주려면 `클래스 추출(Extract Class)`을 해주면 된다. 해당 클래스에 그 변수들과 관련된 모든 코드들을 넣는 것이다.
이를 통해 `메서드 객체(Method Object)` 가 생성된다.

## 메시지 체인 Message Chains

메시지 체인은 클라이언트가 한 객체에 제 2의 객체를 요청하면, 제 2의 객체가 제 3의 객체를 요청하고, 제 3의 객체가 제 4의 객체를 요청하는 식으로 연쇄적 요청이 발생하는 문제점을 뜻한다.
이 체인 사이의 관계들에 수정이 발생할 때마다 클라이언트도 수정해야한다는 문제가 있다.

이럴 때는 `대리 객체 은폐(Hide Delegate)`를 활용할 수 있다.

## 과잉 중개 메서드 Middle Man

객체의 주요 특징 중 한가지는 바로 캡슐화다. 캡슐화란 내부의 세부적인 처리를 외부에서 볼 수 없게 은폐하는 작업을 뜻한다. 캡슐화를 할 때에는 대개 위임이 수반된다.
직원이 부장에게 회의 참석이 가능한지 물어보면, 부장은 그 내용을 자신의 다이어리에 위임하고 직원에게 대답한다. 직원은 부장이 다이어리를 사용하는지, PDA를 이용하는지, 비서에게 물어보는지 알 필요도 없다!

하지만 뭐든 지나치면 문제가 된다. ㅎㅎ 

어떤 클래스의 인터페이스를 봤는데, 그 안의 절반도 넘는 메서드가 기능을 다른 클래스에 위임하고 있다면, 이건 해당 클래스의 존재를 의심하게 된다.
`과잉 중개 메서드 제거(Remove Middle Man)`를 통해 원리가 구현된 객체에 직접 접근하자!

## 지나친 관여 Inappropriate Intimacy

간혹 클래스끼리 관계가 지나치게 밀접한 나머지 서로의 은밀한 부분(private)을 알아내느라 과도한 시간을 낭비하게 될 때가 있다. 
서로 지나치게 관여하는 클래스는 고전에 나오는 비운의 연인처럼 갈라놔야 한다.
`메서드 이동(Move Method)`과 `필드 이동(Move Field)`을 통해서 각 클래스를 분리하고 지나친 관여를 줄여야 한다.

또한 `클래스의 양방향 연결을 단방향으로 전환(Change Bidirectional Association to Unidirectional)하는 것이 좋다.`
Nest.js로 치면 순환참조가 그 예가 될 수 있겠다. 이럴 땐 `클래스 추출(Extract Class)`을 통해서 공통 필요 부분을 별도의 안전한 클래스로 빼내는 것이 좋다.ㅏ
혹은 `대리 객체 은페(Hide Delegate)`을 통해 다른 클래스가 중개 메서드 역할을 하게 만들어도 좋다.

상속으로 인해 지나친 관여가 발생하는 경우가 꽤 많다. 하위클래스는 항상 상위클래스가 공개하는 것보다 많은 데이터를 필요로 한다. 상위클래스에서 하위클래스를 빼내야 할 경우에는 `상속을 위임으로 전환(Replace Inheritance with Delegation)`하면 된다. 

## 인터페이스가 다른 대용 클래스 Alternative Classes with Different Interfaces

기능은 같은데 시그니처가 다른 메서드에는 `메서드명 변경(Rename Method)`을 해야한다. (시그니처 동일하게)

## 미흡한 라이브러리 클래스 Incomplete Library Class

* 외래 클래스에 메서드 추가(Introduce Foreign Method): 라이브러리 클래스에 넣어야할 메서드가 두 개뿐이라면
* 국소적 상속확장 클래스 사용(Introduce Local Extension): 부가 기능이 많을 때

## 데이터 클래스 Data Class

* 데이터 클래스: 필드와 필드 읽기/쓰기 메서드만 들어있는 클래스

데이터 클래스는 오로지 데이터 보관만 담당하며, 거의 대부분의 구체적 데이터 조작은 다른 클래스가 수행한다. 
만약 public 필드라면 즉시 `필드 캡슐화(Encapsulate Field)`를 진행하자. 컬렉션 필드가 있다면 그 필드도 캡슐화 하자. `컬렉션 캡슐화(Encapsulate Collection)`
또한 변경되지 않아야 하는 필드는 `쓰기 메서드를 제거(Remove Setting Method)하자.` final 로 선언하는 것도 좋다.

## 방치된 상속물 Refused Bequest

하위 클래스는 부모 클래스의 메서드와 데이터를 상속 받는다. 그런데 그렇게 상속 받은 것들이 하위클래스에서 더 이상 필요 없다면? 방치가 된다.

기존에는 이 문제의 원인이 "잘못된 계층구조" 때문이라고 판단됐다. 이럴 땐 새 대등 클래스를 작성하고 `메서드 하향(Push Down Method)`과 `필드 하향(Push Down Field)`을 통해서 사용되지 않는 모든 메서드와 필드를 그 형제 클래스에 몰아넣어야 한다.
이렇게 하면 상위 클래스에는 공통 코드만 들어있게 된다.

이건 사실 큰 문제는 아니라, 그냥 냅둬도 된다.

## 불필요한 주석 Comments

주석을 `메서드 추출(Extract Method)`로 대체할 수 있는지 생각해보자. 주석은 웬만한 상황에서 그리 좋지는 않다.